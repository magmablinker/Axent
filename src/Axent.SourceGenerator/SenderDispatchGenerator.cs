using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Axent.SourceGenerator;

[Generator]
public sealed class SenderDispatchGenerator : IIncrementalGenerator
{
    private const string RequestMetadataName = "Axent.Abstractions.IRequest`1";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var requestTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsConcreteClass(node),
                transform: static (ctx, ct) => ExtractRequestTypeInfo(ctx, ct))
            .Where(static info => info is not null);

        var collected =
            requestTypes.Collect();

        context.RegisterSourceOutput(collected, static (spc, types) =>
            Execute(spc, types));
    }

    private static bool IsConcreteClass(SyntaxNode node) =>
        node is ClassDeclarationSyntax { BaseList: not null };

    private static RequestTypeInfo? ExtractRequestTypeInfo(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct) is not INamedTypeSymbol symbol)
            return null;

        if (symbol.IsAbstract || symbol.IsStatic)
            return null;

        var requestSymbol = ctx.SemanticModel.Compilation
            .GetTypeByMetadataName(RequestMetadataName);

        if (requestSymbol is null)
            return null;

        foreach (var iface in symbol.AllInterfaces)
        {
            if (!SymbolEqualityComparer.Default.Equals(
                    iface.OriginalDefinition, requestSymbol))
                continue;

            var responseType = iface.TypeArguments[0];

            return new RequestTypeInfo(
                RequestFullName: symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ResponseFullName: responseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                RequestNamespace: symbol.ContainingNamespace.ToDisplayString()
            );
        }

        return null;
    }

    private static void Execute(
        SourceProductionContext ctx,
        ImmutableArray<RequestTypeInfo?> types)
    {
        IReadOnlyList<RequestTypeInfo> valid = types
            .Where(t => t is not null)
            .Select(t => t!)
            .OrderBy(t => t.RequestFullName) 
            .ToArray();

        if (valid.Count == 0)
            return;

        var source = BuildSource(valid);
        ctx.AddSource("Sender.Dispatch.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string BuildSource(IReadOnlyList<RequestTypeInfo> types)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Axent.Abstractions;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace Axent.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal sealed class GeneratedSender : global::Axent.Abstractions.ISender");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly global::System.IServiceProvider _serviceProvider;");
        sb.AppendLine("    private readonly global::Axent.Abstractions.IRequestContextFactory _requestContextFactory;");
        sb.AppendLine();
        sb.AppendLine("    public GeneratedSender(");
        sb.AppendLine("        global::System.IServiceProvider serviceProvider,");
        sb.AppendLine("        global::Axent.Abstractions.IRequestContextFactory requestContextFactory)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider;");
        sb.AppendLine("        _requestContextFactory = requestContextFactory;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>");
        sb.AppendLine("        SendAsync<TResponse>(");
        sb.AppendLine("            global::Axent.Abstractions.IRequest<TResponse> request,");
        sb.AppendLine("            global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        return request switch");
        sb.AppendLine("        {");

        foreach (RequestTypeInfo type in types)
        {
            sb.AppendLine(
                $"            {type.RequestFullName} __r => " +
                $"(global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>)" +
                $"(object)SendInternalAsync<{type.RequestFullName}, {type.ResponseFullName}>(__r, cancellationToken),");
        }

        sb.AppendLine("            _ => throw new global::System.InvalidOperationException(");
        sb.AppendLine("                     $\"No sender found for request type '{request.GetType().FullName}'.\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private async global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>");
        sb.AppendLine("        SendInternalAsync<TRequest, TResponse>(TRequest request, global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("            where TRequest : class, global::Axent.Abstractions.IRequest<TResponse>");
        sb.AppendLine("    {");
        sb.AppendLine("        var executor    = _serviceProvider.GetRequiredService<global::Axent.Abstractions.IPipelineExecutorService>();");
        sb.AppendLine("        var pipes       = _serviceProvider.GetServices<global::Axent.Abstractions.IAxentPipe<TRequest, TResponse>>();");
        sb.AppendLine("        var handlerPipe = _serviceProvider.GetRequiredService<global::Axent.Abstractions.IHandlerPipe<TRequest, TResponse>>();");
        sb.AppendLine("        var context     = _requestContextFactory.Get(request);");
        sb.AppendLine("        return await executor.ExecuteAsync([..pipes, handlerPipe], context, cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        sb.AppendLine("public static class AxentBuilderExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static global::Axent.Core.AxentBuilder AddSender(");
        sb.AppendLine("        this global::Axent.Core.AxentBuilder builder)");
        sb.AppendLine("    {");
        sb.AppendLine("        builder.Services.AddScoped<global::Axent.Abstractions.ISender, GeneratedSender>();");
        sb.AppendLine("        return builder;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}