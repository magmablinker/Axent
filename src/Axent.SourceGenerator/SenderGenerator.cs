using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Axent.SourceGenerator;

[Generator]
public sealed class SenderGenerator : IIncrementalGenerator
{
    private const string RequestMetadataName = "Axent.Abstractions.IRequest`1";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var requestInterfaceSymbol =
            context.CompilationProvider.Select(
                static (compilation, _) =>
                    compilation.GetTypeByMetadataName(RequestMetadataName));

        var requestTypes =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsCandidate(node),
                    transform: static (ctx, ct) => GetRequestInfo(ctx, ct))
                .Where(static info => info is not null)
                .Combine(requestInterfaceSymbol)
                .Select(static (pair, _) =>
                    TryMatchRequest(pair.Left!, pair.Right))
                .Where(static info => info is not null)
                .Collect();

        context.RegisterSourceOutput(
            requestTypes,
            static (spc, types) => Execute(spc, types));
    }

    private static bool IsCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };
    }

    private static INamedTypeSymbol? GetRequestInfo(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        var symbol =
            ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct)
                as INamedTypeSymbol;

        if (symbol is null)
            return null;

        if (symbol.IsAbstract || symbol.IsStatic)
            return null;

        return symbol;
    }

    private static RequestTypeInfo? TryMatchRequest(
        INamedTypeSymbol type,
        INamedTypeSymbol? requestInterface)
    {
        if (requestInterface is null)
            return null;

        foreach (var symbol in type.AllInterfaces)
        {
            if (!SymbolEqualityComparer.Default.Equals(
                    symbol.OriginalDefinition,
                    requestInterface))
                continue;

            var responseType = symbol.TypeArguments[0];

            return new RequestTypeInfo(
                RequestFullName:
                    type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ResponseFullName:
                    responseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                RequestNamespace:
                    type.ContainingNamespace.ToDisplayString());
        }

        return null;
    }

    private static void Execute(
        SourceProductionContext ctx,
        ImmutableArray<RequestTypeInfo?> types)
    {
        var requests =
            types
                .Where(static t => t is not null)
                .Select(static t => t!)
                .OrderBy(static t => t.RequestFullName)
                .ToImmutableArray();

        if (requests.Length == 0)
            return;

        var source = BuildSource(requests);
        ctx.AddSource(
            "Sender.Dispatch.g.cs",
            SourceText.From(source, Encoding.UTF8));
    }

    private static string BuildSource(
        ImmutableArray<RequestTypeInfo> types)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Axent.Abstractions;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace Axent.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal sealed class Sender : global::Axent.Abstractions.ISender");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly global::System.IServiceProvider _serviceProvider;");
        sb.AppendLine("    private readonly global::Axent.Abstractions.IRequestContextFactory _requestContextFactory;");
        sb.AppendLine();
        sb.AppendLine("    public Sender(");
        sb.AppendLine("        global::System.IServiceProvider serviceProvider,");
        sb.AppendLine("        global::Axent.Abstractions.IRequestContextFactory requestContextFactory)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider;");
        sb.AppendLine("        _requestContextFactory = requestContextFactory;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>");
        sb.AppendLine("        SendAsync<TResponse>(");
        sb.AppendLine("            global::Axent.Abstractions.IRequest<TResponse> request,");
        sb.AppendLine("            global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        return request switch");
        sb.AppendLine("        {");

        foreach (var type in types)
        {
            sb.AppendLine(
                $"            {type.RequestFullName} r => " +
                $"(global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>)" +
                $"(object)SendInternalAsync<{type.RequestFullName}, {type.ResponseFullName}>(r, cancellationToken),");
        }

        sb.AppendLine("            _ => throw new global::System.InvalidOperationException(");
        sb.AppendLine("                     $\"No sender found for request type '{request.GetType().FullName}'.\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private async global::System.Threading.Tasks.Task<global::Axent.Abstractions.Response<TResponse>>");
        sb.AppendLine("        SendInternalAsync<TRequest, TResponse>(");
        sb.AppendLine("            TRequest request,");
        sb.AppendLine("            global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("        where TRequest : class, global::Axent.Abstractions.IRequest<TResponse>");
        sb.AppendLine("    {");
        sb.AppendLine("        var executor = _serviceProvider.GetRequiredService<global::Axent.Abstractions.IPipelineExecutorService>();");
        sb.AppendLine("        var pipes = _serviceProvider.GetServices<global::Axent.Abstractions.IAxentPipe<TRequest, TResponse>>();");
        sb.AppendLine("        var handlerPipe = _serviceProvider.GetRequiredService<global::Axent.Abstractions.IHandlerPipe<TRequest, TResponse>>();");
        sb.AppendLine("        var context = _requestContextFactory.Get(request);");
        sb.AppendLine();
        sb.AppendLine("        return await executor.ExecuteAsync([..pipes, handlerPipe], context, cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("public static class AxentBuilderExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static global::Axent.Core.AxentBuilder AddSender(");
        sb.AppendLine("        this global::Axent.Core.AxentBuilder builder)");
        sb.AppendLine("    {");
        sb.AppendLine("        builder.Services.AddScoped<global::Axent.Abstractions.ISender, Axent.Generated.Sender>();");
        sb.AppendLine("        return builder;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}