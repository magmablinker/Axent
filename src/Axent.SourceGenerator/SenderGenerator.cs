using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Axent.SourceGenerator;

[Generator]
public sealed class SenderGenerator : IIncrementalGenerator
{
    private const string AxentModuleInitializer = "AxentModuleInitializer.g.cs";
    private const string Sender = "Sender.g.cs";

    private const string RequestMetadataName = "Axent.Abstractions.IRequest`1";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource(
                AxentModuleInitializer,
                SourceText.From(BuildModuleInitializerSource(), Encoding.UTF8));
        });

        var requestTypes =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsCandidate(node),
                    transform: static (ctx, ct) => GetRequestInfo(ctx, ct))
                .Where(static info => info is not null)
                .WithComparer(RequestTypeInfo.Comparer)
                .Collect();

        context.RegisterSourceOutput(
            requestTypes,
            static (spc, types) => Execute(spc, types));
    }

    private static bool IsCandidate(SyntaxNode node)
        => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };

    private static RequestTypeInfo? GetRequestInfo(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct) is not INamedTypeSymbol symbol
            || symbol.IsAbstract
            || symbol.IsStatic)
        {
            return null;
        }

        var requestInterface =
            ctx.SemanticModel.Compilation.GetTypeByMetadataName(RequestMetadataName);

        if (requestInterface is null)
        {
            return null;
        }

        foreach (var iface in symbol.AllInterfaces)
        {
            if (!SymbolEqualityComparer.Default.Equals(
                    iface.OriginalDefinition,
                    requestInterface))
            {
                continue;
            }

            var responseType = iface.TypeArguments[0];

            return new RequestTypeInfo(
                RequestFullName:
                    symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ResponseFullName:
                    responseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        return null;
    }

    private static void Execute(
        SourceProductionContext ctx,
        ImmutableArray<RequestTypeInfo?> types)
    {
        var requests =
            types
                .Where(static t => t is not null)
                .Select(static t => t!)
                .OrderBy(static t => t.RequestFullName)
                .ToImmutableArray();

        if (requests.Length == 0)
        {
            return;
        }

        ctx.AddSource(
            Sender,
            SourceText.From(BuildSenderSource(requests), Encoding.UTF8));
    }

    private static string BuildSenderSource(ImmutableArray<RequestTypeInfo> types)
    {
        var sb = new StringBuilder(types.Length * 200); // preallocate

        sb.AppendLine("""
            // <auto-generated />
            #nullable enable
            using System;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            using Axent.Abstractions;
            using Microsoft.Extensions.DependencyInjection;

            namespace Axent.Generated;

            internal sealed class GeneratedSender : ISender
            {
                private readonly IServiceProvider _serviceProvider;
                private readonly IRequestContextFactory _requestContextFactory;

                private static readonly Dictionary<Type, Func<GeneratedSender, object, CancellationToken, Task<object>>> _dispatchers;

                static GeneratedSender()
                {
                    _dispatchers = new Dictionary<Type, Func<GeneratedSender, object, CancellationToken, Task<object>>>
                    {
            """);

        foreach (var type in types)
        {
            sb.AppendLine(
                $"          [typeof({type.RequestFullName})] = (s, r, ct) => s.SendInternalAsync<{type.RequestFullName}, {type.ResponseFullName}>(({type.RequestFullName})r, ct),");
        }

        sb.AppendLine("""
                    };
                }

                public GeneratedSender(IServiceProvider serviceProvider, IRequestContextFactory requestContextFactory)
                {
                    _serviceProvider = serviceProvider;
                    _requestContextFactory = requestContextFactory;
                }

                public async Task<Response<TResponse>> SendAsync<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken)
                {
                    if (_dispatchers.TryGetValue(request.GetType(), out var handler))
                    {
                        var result = await handler(this, request, cancellationToken);
                        return (Response<TResponse>)result;
                    }

                    throw new InvalidOperationException($"No sender found for request type '{request.GetType().FullName}'.");
                }

                private async Task<object> SendInternalAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
                    where TRequest : class, IRequest<TResponse>
                {
                    var executor = _serviceProvider.GetRequiredService<IPipelineExecutorService>();
                    var pipes = _serviceProvider.GetServices<IAxentPipe<TRequest, TResponse>>();
                    var handlerPipe = _serviceProvider.GetRequiredService<IHandlerPipe<TRequest, TResponse>>();
                    var context = _requestContextFactory.Get(request);
                    return await executor.ExecuteAsync([.. pipes, handlerPipe], context, cancellationToken);    }
                }
            """);

        return sb.ToString();
    }

    private static string BuildModuleInitializerSource() =>
        """
        // <auto-generated />
        #nullable enable

        using System.Runtime.CompilerServices;
        using Axent.Abstractions;
        using Axent.Core;
        using Microsoft.Extensions.DependencyInjection;

        namespace Axent.Generated;

        internal static class SenderModuleInitializer
        {
            [ModuleInitializer]
            internal static void Register()
            {
                AxentSenderRegistry.Register(static sp =>
                    new GeneratedSender(
                        sp,
                        sp.GetRequiredService<IRequestContextFactory>()));
            }
        }
        """;
}

internal sealed record RequestTypeInfo(
    string RequestFullName,
    string ResponseFullName)
{
    public static readonly IEqualityComparer<RequestTypeInfo?> Comparer =
        EqualityComparer<RequestTypeInfo?>.Default;
}
